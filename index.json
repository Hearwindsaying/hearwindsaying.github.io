[{"authors":null,"categories":null,"content":"I am a senior at South China Agricultural University. I am keen on realistic rendering, a way of coding the beauty of nature.\nPreviously I worked on analytical area light integration for interests under the supervision of Dr. Li-Yi Wei. My research interests involve efficient sampling and integration for rendering application.\n  Download my resum√©.\n","date":1598918400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1598918400,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am a senior at South China Agricultural University. I am keen on realistic rendering, a way of coding the beauty of nature.\nPreviously I worked on analytical area light integration for interests under the supervision of Dr.","tags":null,"title":"Zihong Zhou","type":"authors"},{"authors":["Zihong Zhou","Li-Yi Wei"],"categories":null,"content":"Summary We present triple sphere, a method to integrate spherical lights over spherical caps via spherical harmonics for rendering applications.\n","date":1598918400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598918400,"objectID":"53e70e40936470c23eef90852de6774e","permalink":"https://hearwindsaying.github.io/publication/triplesphere/","publishdate":"2020-09-01T00:00:00Z","relpermalink":"/publication/triplesphere/","section":"publication","summary":"In *SIGGRAPH Asia 2020 Technical Communications*","tags":[],"title":"Spherical Light Integration over Spherical Caps via Spherical Harmonics","type":"publication"},{"authors":null,"categories":null,"content":"Overview Colvillea is a physically based global illumination renderer running on GPU. It relies on NVIDIA\u0026rsquo;s OptiX to achieve parallelism by leveraging GPU resources, resulting in high performance ray tracing rendering.\nMotivation Here are some motivations and objectives of building Colvillea:\n Ease for implementation of ray tracer in GPU. Writing a GPU renderer from scratch could be of great difficulty and hard to get optimal performance. Debugging is also a pain in the neck. There might be a way out for all these problems thanks to OptiX. Deliver RTX hardware acceleration for faster rendering. OptiX is one of the three ways for enabling RTCores so as to achieve higher ray tracing efficiency when possible. Potential for implementation of some state-of-the-art rendering technologies. This is a personal project written during my learning of computer graphics. In the end, it should be both easy and convenient to extend to adding more features. It\u0026rsquo;s also interesting to try out rendering algorithms in GPU to explore a better efficiency.  Features Light Transport  Direct Lighting Unidirectional Path Tracing  Reflection Models  Lambertian BRDF Specular BRDF (Perfect Mirror) Specular BSDF (Perfect Glass) Ashikhmin-Shirley BRDF (Rough Plastic) GGX Microfacet BRDF (Rough Conductor) GGX Microfacet BSDF (Rough Dielectric) Dielectric-Couductor Two Layered BSDF  Sampler  Independent Sampler Halton QMC Sampler (Fast Random Permutation) Sobol QMC Sampler  Filter (Progressive)  Box filter Gaussian filter  Rendering Mode  Progressive Rendering  Light Source Models  Point Light Quad Light (Spherical Rectangular Sampling) Image-Based Lighting (HDRI Probe)  Camera  Pinhole Camera Depth of Field  Geometry  Triangle Mesh (Wavefront OBJ)  Miscellaneous  LDR/HDR Image I/O with Gamma Correction Interactive rendering with editing scene  Work In Progress  Upgrade to OptiX 7.1 Refactor the renderer architecture: wavefront ray tracing  Build Building Colvillea requires OptiX 6.0 (6.5 is preferred) and CUDA 9.0 or above installed. For graphics driver on Windows platform, driver version 436.02 or later is required. All NVIDIA GPUs of Compute Capability 5.0 (Maxwell) or higher are supported but those with Turing architecture is required to access RTX hardware acceleration.\nColvillea currently builds on Windows only using CMake and could be built using MSVC successfully. It\u0026rsquo;s recommeded that create a separte directory in the same level folder as src folder. Note that you are required to use VS2015 or above targeted for 64-bit as CUDA_HOST_COMPILER in configuration step. For better layout to support interactive rendering, please put imgui.ini file to the same directory as colvillea.vcxproj.\nReferences Nvidia OptiX\nPBRT\nMitsuba\n","date":1594771200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594771200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"https://hearwindsaying.github.io/project/example/","publishdate":"2020-07-15T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"A Physically Based GPU Ray Tracer","tags":["Ray Tracing","GPU","Physically Based Rendering"],"title":"Colvillea","type":"project"},{"authors":[],"categories":[],"content":"","date":1572566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572566400,"objectID":"431c0f3f6aea07e8fa8c5445342b5bd7","permalink":"https://hearwindsaying.github.io/project/livingroom-in-unity/","publishdate":"2019-11-01T00:00:00Z","relpermalink":"/project/livingroom-in-unity/","section":"project","summary":"A course project work for Virtual Reality which explores Lightmapping techniques with the newest High-Definition Rendering Pipeline in Unity. With prebaked global illumination using ray tracing methodology, it brings the Living-Room scene to the word-class game engine.","tags":["Unity","Prebaked Ray Tracing","Digital Art"],"title":"Living-Room in Unity","type":"project"},{"authors":[],"categories":[],"content":"","date":1552176000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552176000,"objectID":"5cf7a14226181e96d6cd8e73955e98fa","permalink":"https://hearwindsaying.github.io/project/simple-photo-viewer/","publishdate":"2019-03-10T00:00:00Z","relpermalink":"/project/simple-photo-viewer/","section":"project","summary":"A simple photoviewer written for OOP course using C++/WinRT deployed at Universal Windows Platform. Common file management operations like copy, paste, remove etc. are supported. Standard C++17 and XAML language are used for the project. Several optimization techniques are employed to provide the user with a smooth interaction when previewing large image files.","tags":[],"title":"Simple Photo Viewer","type":"project"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://hearwindsaying.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["Zihong Zhou"],"categories":["Unity","Rendering"],"content":"Notes This is my final project for a virtual reality and game development course. My contribution is bringing a Benedikt Bitterli\u0026rsquo;s famous rendering scene living-room to Unity and showing how we could use various rasterization techniques to approximate the beauty image produced by offline renderer.\nForewords Ray tracing is an elegant algorithm used in computer graphics to synthesis realistic images. It shoots tremendous rays to find intersection with geometries in the scene and shading with lights and tries its best to simulate the light transport process in nature. The algorithm is not so fast however and it is not unusual to spend hours to days rendering a single image for the complex scenes produced by artists in the movie industry.\nRasterization on the other hand, represents a way to render in an efficient way, which is used ubiquitously in realtime rendering. Thanks to the efforts of many graphics researchers and engineers for many years, realtime rendering could already produce some good-looking images nowadays. Consequently, in this project I\u0026rsquo;d like to find out how good it could be in a game engine.\nNote that these days realtime ray tracing becomes popular due to the introduction of NVIDIA\u0026rsquo;s RTX architecture in Turing GPUs, which is able to do the ray intersection in a lightning fast way. However, it requires a decent graphics card and my old GTX-960M is a bit out-of-date. So I give up the idea and turn to Unity\u0026rsquo;s HDRP Rendering Pipeline (The High Definition Render Pipeline) for the project.\nGeneral To generate an image as realistic as possible, we need to choose a GI (Global Illumination) system in Unity. We will miss the nice indirect lighting, reflections for example if we skip this part.\n   Global Illumination Off Global Illumination On          Unity engine has several built-in solutions for achieving Global Illumination:   Two global illumination systems in Unity engine. Image courtesy of Unity documentation.    Update in 2021: Note that Enlighten is deprecated and we are suggested to use CPU or GPU-based Progressive Lightmapper instead.   I attempted to use Enlighten in the first place and do not have a good experience since it is laborious to play with the parameters so as to reach my expectation. I then turned to CPU and GPU based Progressive Lightmapper for the job. Progressiveness indicates we could have a somewhat coarse preview immediately and it gradually gets refined as we wait. This is usually preferred by lots of artists since it saves time for fast iterations.\nSky and Fog Volume To begin with, we should have a sky!\n  Our sunset skybox for the living room.   I chose to use a sky from HDRI probe, which would also be the primary luminary for our scene. We just need to import our HDRI panorama as a cubemap by setting the Texture Shape as Cube and using Trilinear Filter:\n  Import our skybox with cubemap and trilinear filter.   We could preview our loaded HDRI Sky in the scene as well by setting up the Volume:\n  Set up the HDRI Sky in Volume.   Remember we need to specifiy the sky in the Lighting/Environment HDR.\n  Specify our sky in Lighting.   Cleanup the Scene The living-room scene is from Benedikt Bitterli\u0026rsquo;s Rendering Resources:\n  The living room I chosed.   I first import all meshes (*.obj) into Maya and group the objects by materials according to the provided scene description file (.xml). This could reduce our time for authoring and assigning materials in Unity later.\n  Group and name objects by materials in Maya.   I also check the normals facing outwards and ensure the Y axis is up (the convention Unity uses):\n  Visualize the normal to check the face orientation.   Import the Scene After fixing all issues in the last section, it should work well to export the scene as FBX and import in Unity.\nHowever, there is an issue to be considered \u0026ndash; what is our scale of the scene? This is important since we have limited precision for representing decimal in computer science. For example, the intersection point may slightly below the surface and when it shoots a shadow ray to the light to find out whether it\u0026rsquo;s blocked or not, it will be occluded by itself \u0026ndash; a phenomena known as shadow acne.\n  Shadow acne artifacts due to the error of loating point. Image courtesy of Scratchpixel 2.0.   An idea is to offset the intersection pooint by epsilon, which should be related to the scale of the scene. If our scene lives in a small world, \u0026lsquo;a miss (ray epsilon in this context) is as good as a mile\u0026rsquo;! Our scale or units thus should chosed in a consistent way throughout the scene to avoid these annoying artifacts.\nOne of the simplest solutions is to compare the imported scene with the default primitive in Unity. A standard cube here has the length of 1 meter and I just scale our scene to make it match the scale \u0026ndash; a 5m*10m*5m living room.\n  Scale our scene according to the standard cube in Unity to fix the unit.   Testing Global Illumination After importing the models, it is time for playing around with the global illumination system now! We could first ignore the minute props in the scene such as plants and the statue and check whether the global illumination works well for the \u0026lsquo;global\u0026rsquo; environment, the look of the house. So enable the paneling, ceiling, floor, wall and the fireplace glass only and tick Contribute Global Illumination under Inspector/Mesh Renderer/Lighting.\n  Parameters required to contribute global illumination.   And we could enable the baked GI solution under Lighting/Mixed Lighting and Lighting/Lightmapping Settings.\n  Settings for lightmap baking.   Progressive GPU lightmapper is preferred when we have enough GPU memory (at least 4GB), which is generally the way much faster than the CPU one. It requires us to have a GPU supporting OpenCL 2.2 as well.\nMultiple importance sampling should always be enabled since it helps reduce variance by combining several sampling strategies. Throwing more direct and indirect samples helps reduce noises even more, but it increases the baking time as well. So we have to make a trade-off between the quality and time. But that\u0026rsquo;s not the whole story, since we could apply filtering even if we use fewer number of samples to get a decent result. By selecting the Auto setting for the Filtering, unity will do all the magic for us!\nSince we are using baked GI solution, so we must have a second UV for lightmapping. This is done by Unity by enabling Generate Lightmap UVs during FBX import.\n  Let Unity generate the lightmap UVs for us.   Material and Reflections Since we have already grouped the meshes by materials, we could just assign each group of mesh with a unique material. For the ceiling and the wall, we want a Lambertian BSDF as specified in the xml file. I just use a simple HDRP/Lit shader with Metallic = 0 and Smoothness = 0.\n   Material Base Color     ceiling R=G=B=0.578596   wall R=G=B=0.4528      Setup for our ceiling material to match a Lambertian BSDF.   For the floor and paneling, we need to emulate the substrate BSDF or rough-coating BSDF with the underlying BSDF being Lambertian and coated with a rough dielectric BSDF with GGX distribution.\n  Illustration for light transport in a rough-coating BSDF. Image courtesy of Mitsuba 0.5 documentation.   Thanks to the Laurent Belcour\u0026rsquo;s excellent work on layered material, we could easily simulate this kind of coating material in Unity using StackLit shader.\nWe shall use the Shader Graph to finish the task. Here is what we have for the floor:\n  Shader Graph setup for the layered floor material.   And the paneling material:\n  Shader Graph setup for the paneling.   The last material for our \u0026ldquo;global\u0026rdquo; environment is the fireplace, which is a perfectly smooth specular shader. Besides setting the Smoothness = 1 with StackLit, we need to deal with the reflection. This is one of the nasty stuff in realtime rendering \u0026ndash; though reflection itself is a part of the global illumination, we still need to explicitly achieve the effect by using another technique \u0026ndash; Reflection Probes. Here we create a reflection probe to capture the interior environment for the fireplace. Clicking Bake option under the Lighting, we get the nice reflection for the fireplace!\n  Fix the reflection of our fireplace.   But not for the interior, oops!\n  A weird look of our interior.   It may not be so obvious, but the interior gets reflection from the exterior HDRI or Skybox instead of the interior \u0026ndash; the floor is not missing, but reflecting the bright sky! This is due to the lack of another reflection probe for the scene.\nSo we could easily address this by adding another probe:\n  Use yet another reflection probe for interior reflections.   and bake!\n  A corrected interior look.   Details and Props It looks we are on the right track now, we could start to add more details for the scene!\nAfter enabling all props meshes, we begin with the brushed steel. It is like the fireplace glass, but we set the Metallic = 1 to simulate the metal. As for the painting back and the table wood, we could use the same material with the floor, with different base color textures. The sofa, painting, pot, leaves and dirt are just the Lambertians so HDRP/Lit works well.\nNote that we need to use Translucent material type for the leaves and alpha cutout the geometries according to the leaves map.\n  Material setup for the leaves.   Finally, we use a transparent surface type for the glass material.\n  Material setup for the glass.   Here comes another nasty stuff in realtime rendering \u0026ndash; refraction. Refraction is notoriously difficult to achieve in realtime rendering and is usually approximated by Screen Space Refraction:\n  Enable Screen Space Refraction in the volume setting.   Results and Discussions After adding up all props and setting up the materials correctly, we could simply bake our GI and here is what I get:\n  Final baked result for the living room in Unity!   It looks kind of cool \u0026ndash; perhaps not in a sense of realism but in a artistic style.\n  Path traced reference image rendered by my Colvillea renderer.   By comparing with the ground truth image from the ray tracing [sGT Image], we find that the glass seems to be weird and we lack all the nice occlusion from the objects. As for the user\u0026rsquo;s experience, I think it requires artists to pay more attention to the stuff behind rendering. For example, we have to consider the resolution or padding for the lightmap UVs, tuning the baking parameters, fixing light leaking due to the lack of reflection probes etc.\nHowever, the image generated still looks good and the performance in realtime framerates (~80 FPS) is appealing; or we have to wait for hours to get a noise-free image using offline ray tracing!\nHere is another result by leveraging the post-processing pipeline:\n  Featured image for the living-room after post processing.   References  Unity\u0026rsquo;s Blog for HDRP Unity\u0026rsquo;s Documentation for HDRP ArchViz with Unity\u0026rsquo;s HDRP Fontainebleau Demo \u0026ndash; A Unity\u0026rsquo;s Official Demo for HDRP Laurent Belcour\u0026rsquo;s Layered BSDF Paper  ","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"3e7c96beb89d8a0f21cc803d2163b960","permalink":"https://hearwindsaying.github.io/post/render-the-livingroom-in-unity/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/post/render-the-livingroom-in-unity/","section":"post","summary":"Bring the living-room scene to Unity.","tags":["Project"],"title":"Living-Room in Unity","type":"post"}]